{"version":3,"sources":["logic/board_iterators.js","ui/game.js","logic/ai.js","logic/game.js","logic/players.js","App.js","reportWebVitals.js","index.js"],"names":["DIRECTIONS","x","y","iterateCells","cells","start","direction","handler","handleCell","CheckHandler","myColor","this","otherColor","WHITE","BLACK","hasOtherPieces","endsWithEmptySpace","endPoint","value","FlipHandler","flip","piecesToFlip","push","AVAILABLE","RenderGame","game","props","React","Component","RenderBoard","row","column","isGameFinished","getCurrentPlayer","blackPlayer","isLegalClick","makeHumanMove","getPossibleMoves","state","boardState","legalCell","isLegal","possibleMoves","Cell","onClick","handleClick","i","length","renderCell","className","text","gameState","currentPlayer","winner","consecutivePasses","playerWhoPassed","rows","renderRow","buttonClass","utilityFunction","color","counter","j","applyMove","move","newBoardState","array","result","Array","slice","clone2dArray","piece","Game","whitePlayer","getInitialState","triggerMove","turnCounter","includes","player","setState","prevState","forceUpdate","Promise","resolve","setTimeout","pass","registerMove","getWinner","white","black","cellsArray","fill","isValidMove","getEndPoint","Player","HumanPlayer","resolvePromise","AiPlayer","HeuristicAiPlayer","heuristic","maxDepth","minmax","Number","NEGATIVE_INFINITY","POSITIVE_INFINITY","computerMove","currentDepth","node","currentColor","alpha","beta","isTerminalState","bestValue","Infinity","bestNode","bestMove","newEvaluatedNode","Math","max","min","hasEmptyCells","biasTable","ImprovedAiPlayer","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.0edf256a.chunk.js","sourcesContent":["// thanks https://stackoverflow.com/a/44738696\r\n\r\nimport { BLACK, WHITE } from \"./game\";\r\n\r\nconst DIRECTIONS = [\r\n    {x: 0, y: 1}, {x: 1, y: 1}, {x: 1, y: 0}, {x: 1, y: -1},\r\n    {x: 0, y: -1}, {x: -1, y: -1}, {x: -1, y: 0}, {x: -1, y: 1}\r\n];\r\n\r\n// iteration should start from my pieces only.\r\nconst iterateCells = (cells, start, direction, handler) => {\r\n    for (let x = start.x + direction.x, y = start.y + direction.y;\r\n         x >= 0 && x < 8 && y >=0 && y < 8;\r\n         x += direction.x, y += direction.y) {\r\n        if (!handler.handleCell(x, y, cells[x][y])) {\r\n            break;\r\n        }\r\n    }\r\n}\r\n\r\n// handler to handle checking\r\nclass CheckHandler {\r\n\r\n    constructor(myColor) {\r\n        this.myColor = myColor;\r\n        this.otherColor = myColor === WHITE ? BLACK : WHITE;\r\n        this.hasOtherPieces = false;\r\n        this.endsWithEmptySpace = false;\r\n        this.endPoint = null;\r\n    }\r\n\r\n    // Returns whether the search in this direction should be continued\r\n    handleCell(x, y, value) {\r\n        this.endPoint = {x, y};\r\n        if (value === this.otherColor) {\r\n            this.hasOtherPieces = true;\r\n            return true;\r\n        }\r\n        if (value === this.myColor) {\r\n            return false;\r\n        }\r\n        if (value == null) {\r\n            this.endsWithEmptySpace = true;\r\n            return false;\r\n        }\r\n    }\r\n\r\n    isValidMove() {\r\n        return this.hasOtherPieces && this.endsWithEmptySpace;\r\n    }\r\n\r\n    getEndPoint() {\r\n        return this.endPoint;\r\n    }\r\n\r\n}\r\n\r\nclass FlipHandler {\r\n\r\n    constructor(myColor) {\r\n        this.myColor = myColor;\r\n        this.otherColor = myColor === WHITE ? BLACK : WHITE;\r\n        this.flip = false;\r\n        this.piecesToFlip = [];\r\n    }\r\n\r\n    handleCell(x, y, value) {\r\n        if (value === this.otherColor) {\r\n            this.piecesToFlip.push({x, y});\r\n            return true;\r\n        }\r\n        if (value === this.myColor) {\r\n            this.flip = true;\r\n            return false;\r\n        }\r\n        if (value == null) {\r\n            return false;\r\n        }\r\n    }\r\n}\r\n\r\nexport { DIRECTIONS, iterateCells, CheckHandler, FlipHandler };","import React from 'react'\r\nimport './game.css'\r\nimport { BLACK, WHITE, getPossibleMoves } from '../logic/game'\r\n\r\nconst AVAILABLE = 'available';\r\nconst TIE = 'tie';\r\n\r\nexport class RenderGame extends React.Component {\r\n    render() {\r\n        return (\r\n            <div>\r\n                <RenderBoard game={this.props.game}/>\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport class RenderBoard extends React.Component {\r\n\r\n    handleClick(row, column) {\r\n        const game = this.props.game;\r\n\r\n        if (game.isGameFinished()\r\n            || game.getCurrentPlayer() !== game.blackPlayer\r\n            || !this.isLegalClick(game, row, column)) return;\r\n        // TODO: return if pass is happening\r\n\r\n        // game.blackPlayer.makeMove({x: row, y: column});\r\n        game.makeHumanMove({x: row, y: column});\r\n    }\r\n\r\n    isLegalClick(game, row, column) {\r\n        for (const legalCell of getPossibleMoves(game.blackPlayer, game.state.boardState)) {\r\n            if (legalCell.x === row && legalCell.y === column) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    renderCell(row, column) {\r\n        const game = this.props.game;\r\n\r\n        let value;\r\n\r\n        if (game.getCurrentPlayer() !== game.blackPlayer) {\r\n            value = game.state.boardState[row][column];\r\n        } else { // check if this is a legal move\r\n            let isLegal = false;\r\n            const possibleMoves = getPossibleMoves(game.blackPlayer, game.state.boardState);\r\n\r\n            for (const legalCell of possibleMoves) {\r\n                if (legalCell.x === row && legalCell.y === column) {\r\n                    isLegal = true;\r\n                    value = AVAILABLE;\r\n                    break;\r\n                }\r\n            }\r\n            if (!isLegal) value = game.state.boardState[row][column];\r\n        }\r\n\r\n        return <Cell value={value}\r\n                     onClick={() => this.handleClick(row, column)} key={`${row}_${column}`}/>;\r\n    }\r\n\r\n    renderRow(row) {\r\n        const cells = [];\r\n        for (let i = 0; i < this.props.game.state.boardState[row].length; i++) {\r\n            cells.push(this.renderCell(row, i));\r\n        }\r\n        return <div className=\"board-row\" key={row}>{cells}</div>;\r\n    }\r\n\r\n    render() {\r\n        const game = this.props.game;\r\n        const gameState = game.state;\r\n        const currentPlayer = game.getCurrentPlayer() === game.blackPlayer ? 'black' : 'white';\r\n\r\n        let text;\r\n        if (gameState.winner) {\r\n            if (gameState.winner === TIE) text = 'Tie';\r\n            else text = 'Winner: ' + gameState.winner;\r\n        } else {\r\n            if (gameState.consecutivePasses !== 0) {\r\n                // passing\r\n                const playerWhoPassed = // this is not a typo! prev player passed\r\n                    game.getCurrentPlayer() === game.blackPlayer ? 'white' : 'black';\r\n                text = `Player ${playerWhoPassed}: PASS, next player: ${currentPlayer}`;\r\n            }\r\n            else text = 'Next player: ' + currentPlayer;\r\n        }\r\n\r\n        const rows = [];\r\n        for (let i = 0; i < gameState.boardState.length; i++) {\r\n            rows.push(this.renderRow(i));\r\n        }\r\n\r\n        return (\r\n            <div>\r\n                <div className=\"status\">{text}</div>\r\n                <div className=\"board\">\r\n                    {rows}\r\n                </div>\r\n            </div>\r\n        );\r\n    }\r\n\r\n}\r\n\r\nfunction Cell(props) {\r\n    let buttonClass;\r\n    switch (props.value) {\r\n        case WHITE:\r\n            buttonClass = 'board-cell-white';\r\n            break;\r\n        case BLACK:\r\n            buttonClass = 'board-cell-black';\r\n            break;\r\n        case AVAILABLE:\r\n            buttonClass = 'board-cell-available';\r\n            break;\r\n        default:\r\n            buttonClass = 'board-cell';\r\n            break;\r\n    }\r\n\r\n    return (\r\n        <button className={buttonClass} onClick={props.onClick}>\r\n\r\n        </button>\r\n    );\r\n}","// thanks https://towardsdatascience.com/create-ai-for-your-own-board-game-from-scratch-minimax-part-2-517e1c1e3362\r\nimport {DIRECTIONS, FlipHandler, iterateCells} from \"./board_iterators\";\r\nimport {BLACK, WHITE, getPossibleMoves} from \"./game\";\r\n\r\n// is applied to terminal positions to determine their value\r\nexport function utilityFunction(color, boardState) {\r\n    let counter = 0;\r\n    for (let i = 0; i < 8; i++) {\r\n        for (let j = 0; j < 8; j++) {\r\n            if (boardState[i][j] === color) counter++;\r\n        }\r\n    }\r\n    return counter;\r\n}\r\n\r\nfunction clone2dArray(array) {\r\n    const result = Array(array.length);\r\n    for (let i = 0; i < array.length; i++) {\r\n        result[i] = array[i].slice();\r\n    }\r\n    return result;\r\n}\r\n\r\nexport function applyMove(boardState, color, move) {\r\n    const newBoardState = clone2dArray(boardState);\r\n    newBoardState[move.x][move.y] = color;\r\n\r\n    // flipping pieces\r\n    for (const direction of DIRECTIONS) {\r\n        const handler = new FlipHandler(color);\r\n        iterateCells(boardState, move, direction, handler);\r\n        if (handler.flip) {\r\n            for (const piece of handler.piecesToFlip) {\r\n                newBoardState[piece.x][piece.y] = color;\r\n            }\r\n        }\r\n    }\r\n\r\n    return newBoardState;\r\n}","import React from 'react';\r\nimport { CheckHandler, DIRECTIONS, iterateCells } from \"./board_iterators\";\r\nimport { RenderGame } from \"../ui/game\";\r\nimport {applyMove} from \"./ai\";\r\n\r\nexport const BLACK = true;\r\nexport const WHITE = false;\r\n\r\nexport default class Game extends React.Component {\r\n\r\n    constructor(props) {\r\n        super(props);\r\n        this.blackPlayer = props.blackPlayer;\r\n        this.whitePlayer = props.whitePlayer;\r\n        this.state = Game.getInitialState();\r\n        // this.gameLoop();\r\n        this.blackPlayer.triggerMove(this);\r\n    }\r\n\r\n    static getInitialState() {\r\n        const cellsArray = [];\r\n        for (let i = 0; i < 8; i++) {\r\n            cellsArray[i] = Array(8).fill(null);\r\n        }\r\n        cellsArray[3][3] = BLACK;\r\n        cellsArray[4][4] = BLACK;\r\n        cellsArray[3][4] = WHITE;\r\n        cellsArray[4][3] = WHITE;\r\n\r\n        return {\r\n            boardState: cellsArray,\r\n            turnCounter: 0,\r\n            consecutivePasses: 0,\r\n        }\r\n    }\r\n\r\n    getCurrentPlayer() {\r\n        return this.state.turnCounter % 2 === 0 ? this.blackPlayer : this.whitePlayer;\r\n    }\r\n\r\n    isGameFinished() {\r\n        if (this.state.consecutivePasses === 2) return true;\r\n\r\n        for (let i = 0; i < 8; i++) {\r\n            // if there are empty cells on the board\r\n            if (this.state.boardState[i].includes(null)) return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    registerMove(player, move) {\r\n        this.setState((prevState) => {\r\n            return {\r\n                boardState: applyMove(prevState.boardState, player.color, move),\r\n                turnCounter: prevState.turnCounter + 1,\r\n                consecutivePasses: 0,\r\n            };\r\n        });\r\n        this.forceUpdate();\r\n    }\r\n\r\n    async pass() {\r\n        return new Promise((resolve => {\r\n            this.setState((prevState) => {\r\n                return {\r\n                    turnCounter: prevState.turnCounter + 1,\r\n                    consecutivePasses: prevState.consecutivePasses + 1,\r\n                };\r\n            });\r\n            this.forceUpdate();\r\n            setTimeout(() => resolve(), 2000);\r\n        }));\r\n    }\r\n\r\n    /*async gameLoop() {\r\n        while (!this.isGameFinished()) {\r\n            const player = this.getCurrentPlayer();\r\n            const move = await player.nextMove(this.state.boardState);\r\n            console.log(player, move);\r\n            if (move == null) await this.pass();\r\n            else this.registerMove(player, move);\r\n        }\r\n\r\n        this.setState({\r\n            consecutivePasses: 0,\r\n            winner: this.getWinner(),\r\n        });\r\n    }*/\r\n\r\n    async makeHumanMove(move) {\r\n        if (move == null) {\r\n            await this.pass();\r\n        } else {\r\n            this.registerMove(this.blackPlayer, move);\r\n        }\r\n        if (!this.isGameFinished()) {\r\n            this.whitePlayer.triggerMove(this);\r\n        } else this.setState({\r\n            consecutivePasses: 0,\r\n            winner: this.getWinner(),\r\n        });\r\n    }\r\n\r\n    async computerMove(move) {\r\n        if (move == null) {\r\n            await this.pass();\r\n        } else {\r\n            this.registerMove(this.whitePlayer, move);\r\n        }\r\n        if (this.isGameFinished()) this.setState({\r\n            consecutivePasses: 0,\r\n            winner: this.getWinner(),\r\n        });\r\n    }\r\n\r\n    getWinner() {\r\n        let white = 0;\r\n        let black = 0;\r\n        for (let i = 0; i < 8; i++) {\r\n            for (let j = 0; j < 8; j++) {\r\n                switch (this.state.boardState[i][j]) {\r\n                    case WHITE:\r\n                        white++;\r\n                        break;\r\n                    case BLACK:\r\n                        black++;\r\n                        break;\r\n                    default:\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n        if (white === black) return 'TIE';\r\n        if (white > black) return 'WHITE';\r\n        else return 'BLACK';\r\n    }\r\n\r\n    render() {\r\n        return <RenderGame game={this}/>;\r\n    }\r\n\r\n}\r\n\r\nexport function getPossibleMoves(player, boardState) {\r\n    const possibleMoves = [];\r\n    for (let x = 0; x < 8; x++) {\r\n        for (let y = 0; y < 8; y++) {\r\n            // only start iterating from taken spots\r\n            if (boardState[x][y] === player.color) {\r\n\r\n                // iterate in all directions\r\n                for (const direction of DIRECTIONS) {\r\n\r\n                    const handler = new CheckHandler(player.color);\r\n                    iterateCells(boardState, {x, y}, direction, handler);\r\n                    if (handler.isValidMove()) possibleMoves.push(handler.getEndPoint());\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return possibleMoves;\r\n}","import { getPossibleMoves, WHITE, BLACK } from \"./game\";\r\nimport { applyMove, utilityFunction } from \"./ai\";\r\n\r\nclass Player {\r\n    constructor(color) {\r\n        this.color = color;\r\n    }\r\n}\r\n\r\nexport class HumanPlayer extends Player {\r\n\r\n    makeMove(move) {\r\n        this.resolvePromise(move);\r\n    }\r\n\r\n    triggerMove(game) {\r\n        if (getPossibleMoves(this, game.state.boardState).length === 0) {\r\n            game.makeHumanMove(null);\r\n        }\r\n    }\r\n\r\n}\r\n\r\nclass AiPlayer extends Player {}\r\n\r\nexport class RandomAiPlayer extends AiPlayer {\r\n\r\n    triggerMove(game) {\r\n        setTimeout(() => {\r\n            const moves = getPossibleMoves(this, game.state.boardState);\r\n            game.computerMove(moves.length === 0\r\n                ? null\r\n                : moves[Math.floor(Math.random() * moves.length)]);\r\n        }, 2000);\r\n    }\r\n\r\n}\r\n\r\nclass HeuristicAiPlayer extends AiPlayer {\r\n\r\n    constructor(heuristic, color, maxDepth) {\r\n        super(color);\r\n        this.heuristic = heuristic;\r\n        this.maxDepth = maxDepth;\r\n    }\r\n\r\n    triggerMove(game) {\r\n        setTimeout(() => {\r\n            const result = this.minmax(0,\r\n                {\r\n                    boardState: game.state.boardState,\r\n                    value: null,\r\n                    move: null,\r\n                }, this.color, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY);\r\n            game.computerMove(result.move);\r\n        }, 2000);\r\n    }\r\n\r\n    // returns the best node with value and move filled\r\n    // alpha - best value for minimizing player so far\r\n    // beta - best value for maximizing player so far\r\n    minmax(currentDepth, node, currentColor, alpha, beta) {\r\n        if (currentDepth === this.maxDepth || this.isTerminalState(node)) {\r\n            node.value = this.heuristic(this.color, node.boardState, node.move);\r\n            return node;\r\n        }\r\n\r\n        let bestValue = currentColor === WHITE ? -1 : Infinity;\r\n        let bestNode = null;\r\n        let bestMove = null;\r\n\r\n        for (const move of getPossibleMoves({color: currentColor}, node.boardState)) {\r\n            const newBoardState = applyMove(node.boardState, currentColor, move, alpha, beta);\r\n\r\n            const newEvaluatedNode = this.minmax(currentDepth + 1, {\r\n                boardState: newBoardState,\r\n                value: null,\r\n                move, // this move is made by alternating players!\r\n            }, !currentColor);\r\n\r\n            if (currentColor === WHITE && bestValue < newEvaluatedNode.value) {\r\n                bestValue = newEvaluatedNode.value;\r\n                bestNode = newEvaluatedNode;\r\n                bestMove = move;\r\n                alpha = Math.max(alpha, bestValue);\r\n                if (beta <= alpha) {\r\n                    break;\r\n                }\r\n            } else if (currentColor === BLACK && bestValue > newEvaluatedNode.value) {\r\n                bestValue = newEvaluatedNode.value;\r\n                bestNode = newEvaluatedNode;\r\n                bestMove = move;\r\n                beta = Math.min(beta, bestValue);\r\n                if (beta <= alpha) {\r\n                    break;\r\n                }\r\n            }\r\n\r\n\r\n        }\r\n\r\n        if (bestNode === null) {\r\n            bestNode = node;\r\n            bestValue = this.heuristic(this.color, node.boardState, node.move);\r\n        }\r\n\r\n        bestNode.value = bestValue;\r\n        bestNode.move = bestMove;\r\n        return bestNode;\r\n    }\r\n\r\n    isTerminalState(node) {\r\n        // if there are empty cells on the board\r\n        let hasEmptyCells = false;\r\n        for (let i = 0; i < 8; i++) {\r\n            for (let j = 0; j < 8; j++) {\r\n                if (node.boardState[i][j] == null) {\r\n                    hasEmptyCells = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (hasEmptyCells) break;\r\n        }\r\n\r\n        return !hasEmptyCells;\r\n    }\r\n\r\n}\r\n\r\nexport class GreedyAiPlayer extends HeuristicAiPlayer {\r\n\r\n    constructor(color) {\r\n        super((color, boardState, move) => utilityFunction(color, boardState),\r\n            color, 4);\r\n    }\r\n\r\n}\r\n\r\nconst biasTable = [\r\n    [4, 1, 2, 1, 1, 2, 1, 4],\r\n    [1, 1, 2, 1, 1, 2, 1, 1],\r\n    [2, 2, 2, 1, 1, 2, 2, 2],\r\n    [1, 1, 1, 1, 1, 1, 1, 1],\r\n    [1, 1, 1, 1, 1, 1, 1, 1],\r\n    [2, 2, 2, 1, 1, 2, 2, 2],\r\n    [1, 1, 2, 1, 1, 2, 1, 1],\r\n    [4, 1, 2, 1, 1, 2, 1, 4],\r\n];\r\n\r\nexport class ImprovedAiPlayer extends HeuristicAiPlayer {\r\n    constructor(color) {\r\n        super((color, boardState, move) => {\r\n            if (move === null) return utilityFunction(color, boardState);\r\n            else return utilityFunction(color, boardState) * biasTable[move.x][move.y];\r\n        }, color, 4);\r\n    }\r\n}\r\n","import Game, {BLACK, WHITE} from \"./logic/game\";\nimport './App.css';\nimport React from \"react\";\nimport { HumanPlayer, ImprovedAiPlayer } from \"./logic/players\";\n\nexport default function App() {\n    const blackPlayer = new HumanPlayer(BLACK);\n    const whitePlayer = new ImprovedAiPlayer(WHITE);\n\n    return (\n        <div className=\"App\">\n          <Game blackPlayer={blackPlayer} whitePlayer={whitePlayer}/>\n        </div>\n    );\n}","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}